# Universal printf

*uprintf* is a header-only library for printing anything in C/C++.

## Examples

Examples and their outputs can be found in [examples](examples), and can be built using `make examples`.

### Example outputs

<details>
  <summary>avl (<a href="https://github.com/etherealvisage/avl">src</a>)</summary>

```c
!examples/avl.out
```
</details>

<details>
  <summary>sqlite (<a href="https://www.sqlite.org">src</a>)</summary>

```c
!examples/sqlite.out
```
</details>

<details>
  <summary>vorbis (<a href="https://github.com/nothings/stb/blob/master/stb_vorbis.c">src</a>)</summary>

```c
!examples/vorbis.out
```
</details>

<details>
  <summary>miniaudio (<a href="https://github.com/mackron/miniaudio">src</a>)</summary>

```c
!examples/miniaudio.out
```
</details>

<details>
  <summary>uprintf</summary>

```c
!examples/uprintf.out
```
</details>

<details>
  <summary>cxxopts (<a href="https://github.com/jarro2783/cxxopts">src</a>)</summary>

```c
!examples/cxxopts.out
```
</details>

<details>
  <summary>taskflow (<a href="https://github.com/taskflow/taskflow">src</a>)</summary>

```c
!examples/taskflow.out
```
</details>

## Requirements

- Works only on Linux
- Minimum C version is c99 (tests require c11)
- Minimum C++ version is c++11
- Executable must be compiled with debugging information (`-g2` or `-g3`)

## Usage

1. [Download](https://raw.githubusercontent.com/spevnev/uprintf/refs/heads/main/uprintf.h) the library, or clone the repo

2. Define `UPRINTF_IMPLEMENTATION` in one of the files:
    ```c
    #define UPRINTF_IMPLEMENTATION
    #include "uprintf.h"
    ```
    The implementation must be included in **only one** of the files. \
    A rarely modified file should be used because it increases the build time. \
    [Options](#options) can be defined before the implementation.

3.
    ```c
    uprintf(fmt, ...);
    ```
    `fmt` - a format string with placeholders (`%` followed by any letter). Use `%%` to print `%`. \
    For every placeholder, there must be an argument which is a **pointer** to the data that should be printed.

### Options

Options must be defined **before** the implementation:

```c
#define OPTION_NAME VALUE
#define UPRINTF_IMPLEMENTATION
#include "uprintf.h"
```

option | description | default
-|-|-
`UPRINTF_INDENTATION_WIDTH` | The number of spaces to use for indentation | 4
`UPRINTF_MAX_DEPTH` | Limits the nesting depth of structures. Negative values remove the limit | 10
`UPRINTF_IGNORE_STRUCTS` | Comma-separated list of struct names whose values should not be printed | FILE,pthread_mutex_t,pthread_cond_t
`UPRINTF_ARRAY_COMPRESSION_THRESHOLD` | The number of consecutive identical array elements before they get compressed. Non-positive values disable compression | 4
`UPRINTF_MAX_STRING_LENGTH` | The length before the string gets truncated. Non-positive values remove the limit | 200

## Limitations

- Dynamic arrays can only be printed as pointers because there is no information about its length.
    ```c
    int *arr = malloc(sizeof(*arr) * 3);
    arr[0] = 1;
    arr[1] = 2;
    arr[2] = 3;
    uprintf("%S\n", &arr); // 0x12345678 (1)
    ```

- Printing information about function from a shared library only works with gcc:
    ```c
    uprintf("%S\n", printf);
    // gcc  : 0x12345678 (int printf(const char *, ...))
    // clang: 0x12345678
    ```

- Incorrect type deduction when printing variables that get shadowed *later* in the same scope.
    ```c
    char var = 'c';
    {
        uprintf("%S\n", &var); // interprets char as an int
        int var = 1;
        uprintf("%S\n", &var); // prints int
    }
    ```

- Casting to struct/union defined in arguments is not supported.
    ```c
    uprintf("%S\n", &(struct { int i; float f; }) { 1, 2.3F }); // unsupported
    ```

- Some functions and types may get inlined and have debugging information omitted by the compiler.

### C++

- `typeid` is not supported.
    ```cpp
    int x = 10;
    uprintf("%S\n", &typeid(x)); // unsupported
    ```

- `decltype` in arguments is not supported.
    ```cpp
    int x = 10;
    int y = 20;
    uprintf("%S\n", (decltype(x) *) &y); // unsupported
    ```

- Lambda definitions in arguments is not supported.
    ```cpp
    uprintf("%S\n", [&]() { ... }()); // unsupported
    ```

- Templated variable and functions in arguments are not supported.
    ```cpp
    template <typename T>
    T var = T{};

    template <typename T>
    T foo(T a) { return a; }

    uprintf("%S\n", &var<int>); // unsupported
    uprintf("%S\n", &foo<int>); // unsupported
    ```

- Invoking overloaded operators in arguments is not supported.
      ```cpp
      T operator+(const T &a, const T &b);

      T a, b;
      // + expects integers ignoring the overloaded version.
      uprintf("%S\n", a + b);
      ```

## How it works

The library uses debugging information to get type information required for printing.

On initialization:
1. Read the current binary.
2. Parse ELF and DWARF.
3. Store metadata about scopes and types.

On each invocation:
1. Identify current scope based on the PC.
2. Parse the arguments string.
3. Look up arguments' types based on current scopes.
4. Print the data using type definition.

## Testing

### Tested compilers

- gcc & g++: 11, 12, 13, 14
- clang & clang++: 14, 15, 16, 17, 18

### Running tests

```console
$ make test
```
